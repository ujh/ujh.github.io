<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Urban Hafner]]></title>
  <link href="http://bettong.net/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://bettong.net/"/>
  <updated>2016-03-09T10:34:22+01:00</updated>
  <id>http://bettong.net/</id>
  <author>
    <name><![CDATA[Urban Hafner]]></name>
    <email><![CDATA[contact@urbanhafner.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rust testing with stainless]]></title>
    <link href="http://bettong.net/2016/03/09/rust-testing-with-stainless/"/>
    <updated>2016-03-09T09:39:07+01:00</updated>
    <id>http://bettong.net/2016/03/09/rust-testing-with-stainless</id>
    <content type="html"><![CDATA[<p>A <a href="https://github.com/reem/stainless/issues/48">recent discussion</a> in the issues of <a href="https://github.com/reem/stainless">stainless</a> prompted me to write a small blog post that explains the basics of testing in Rust using stainless. <em>Note that stainless only works with the nightly Rust compiler as it requires compiler plugins.</em></p>

<p>First of all, let&rsquo;s set up the project. We will build a library and write unit as well as integration tests for it (code by <a href="https://github.com/xetra11">xetra11</a>). Here&rsquo;s the <code>Cargo.toml</code> file:</p>

<pre><code class="toml Cargo.toml">[package]
name = "renderay_rs"
version = "0.0.1"
authors = ["xetra11 &lt;falke_88@hotmail.com&gt;"]

[lib]
path = "src/renderay_core.rs"

[dependencies]
stainless = { git = "https://github.com/reem/stainless.git" }
</code></pre>

<p>So now let&rsquo;s look at the main entry point of the library. The code is just for illustration purposes and we don&rsquo;t really care what it does. We do however care about the first three lines.</p>

<p><code>#![feature(plugin)]</code> tells the Rust compiler to turn on support for compiler plugins. As stainless is a compiler plugin this is needed.</p>

<p>The line after that is a bit more complicated. It does the following: It first checks if we are currently compiling for testing (e.g. running <code>cargo test</code>) If that is the case then we add the line <code>#![plugin(stainless)]</code> which enables stainless. If we don&rsquo;t compile for testing then we do nothing, i.e. we don&rsquo;t enable stainless when compiling normally (e.g. when running <code>cargo build</code>) <a href="http://chrismorgan.info/blog/rust-cfg_attr.html">See this blog post</a> for an in depth explanation if <code>cfg_attr</code>.</p>

<p>And then we define a submodule called <code>test</code>. This is where we will write our unit tests.</p>

<pre><code class="rust src/renderay_core.rs">#![feature(plugin)]
#![cfg_attr(test, plugin(stainless))]

mod test;

pub struct Canvas {
    width: usize,
    height: usize,
    array: Vec&lt;char&gt;
}

impl Canvas {

    pub fn new(width: usize, height: usize, array: Vec&lt;char&gt;) -&gt; Canvas {
        Canvas {
            width: width,
            height: height,
            array: array,
        }
    }

    pub fn array(&amp;self) -&gt; &amp;Vec&lt;char&gt; {
        &amp;self.array
    }

}

pub struct CanvasRenderer&lt;'a&gt; {
    canvas: &amp;'a mut Canvas
}

impl &lt;'a&gt;CanvasRenderer&lt;'a&gt; {
    pub fn new(canvas: &amp;'a mut Canvas) -&gt; CanvasRenderer {
        CanvasRenderer {
            canvas: canvas
        }
    }

    pub fn render_point(&amp;mut self, fill_symbol: char, pos_x: usize, pos_y: usize) {
        let canvas = &amp;mut self.canvas;
        let mut array_to_fill = &amp;mut canvas.array;
        let max_width: usize = canvas.width;
        let max_height: usize = canvas.height;
        let pos_to_draw = pos_x * pos_y;

        if pos_x &gt; max_width || pos_y &gt; max_height {
            panic!("Coordinates are out of array bounds")
        }

        array_to_fill[pos_to_draw] = fill_symbol;

    }
}
</code></pre>

<p>Alright, so let&rsquo;s have a look at the unit tests. First we configure the module as a test module (doesn&rsquo;t need to be compiled normally). Then we add our <code>use</code> declarations for the things we want to use in our tests. Due to implementation details of stainless we need to <code>pub use</code>. And they also need to be <em>outside</em> of the <code>describe!</code> blocks.</p>

<p>And then we come to the actual things added by stainless. <code>describe!</code>, <code>before_each</code>, and <code>it</code>. If you know <a href="http://rspec.info/">rspec</a> then this will look very familiar. <code>it</code> is used to define individual tests and <code>describe!</code> is used to group tests. And <code>before_each</code> is executed before each test in a group of tests.</p>

<p><em>If you look closely you will notice that due to the fact that the test module is a submodule of the code that we&rsquo;re testing we have access to private functions and private struct fields.</em></p>

<pre><code class="rust src/test.rs">#![cfg(test)]

pub use super::CanvasRenderer;
pub use super::Canvas;

describe! canvas_renderer {

    before_each {
        let mut canvas = Canvas {
            width: 10,
            height: 10,
            array: vec!['x';10*10],
        };
    }

    it "should fill given char at given coords" {
        {
            let mut renderer: CanvasRenderer = CanvasRenderer::new(&amp;mut canvas);
            renderer.render_point('x', 3,3);
        }
        assert_eq!('x', canvas.array[3*3]);
    }
}
</code></pre>

<p>Oh, and as we&rsquo;re writing a library we of course should also write integration tests. These go into the <code>tests/</code> folder of the project. It looks similar to our unit tests, but a few things are different:</p>

<ol>
<li>We can just use <code>#![plugin(stainless)]</code> as we will never compile this code outside of our tests.</li>
<li>We need to add the library we&rsquo;re building as an external crate (through <code>extern crate renderay_rs;</code>) as this is a separate executable.</li>
<li>We cannot use private functions of struct fields here. So we need to use <code>Canvas::new</code> and a getter for the array.</li>
</ol>


<pre><code class="rust tests/render_point.rs">#![feature(plugin)]
#![plugin(stainless)]

extern crate renderay_rs;

pub use renderay_rs::CanvasRenderer;
pub use renderay_rs::Canvas;

describe! integration_test {

    before_each {
        let mut canvas = Canvas::new(10, 10, vec!['x';10*10]);
    }

    it "should fill given char at given coords" {
        {
            let mut renderer: CanvasRenderer = CanvasRenderer::new(&amp;mut canvas);
            renderer.render_point('x', 3,3);
        }
        assert_eq!('x', canvas.array()[3*3]);
    }

}
</code></pre>

<p>And running the tests looks like this:</p>

<pre><code class="text">uh@macaron:~/renderay_rs$ cargo test
    Running target/debug/render_point-f60500163e82a187

running 1 test
test integration_test::should_fill_given_char_at_given_coords ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

    Running target/debug/renderay_rs-42155898cc4eb950

running 1 test
test test::canvas_renderer::should_fill_given_char_at_given_coords ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

    Doc-tests renderay_rs

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why every agile team should include a tester]]></title>
    <link href="http://bettong.net/2015/07/03/why-every-agile-team-should-include-a-tester/"/>
    <updated>2015-07-03T07:26:31+02:00</updated>
    <id>http://bettong.net/2015/07/03/why-every-agile-team-should-include-a-tester</id>
    <content type="html"><![CDATA[<p>A
<a href="http://softwaresaltmines.com/2015/06/30/endangered-species-managers-and-directors-of-quality-assurance/">recent post on Jim Grey&rsquo;s blog about his job hunt as a QA manager</a>
made me think about what my ideal test setup for an agile (SCRUM like)
team would be.</p>

<p>The thing is, having QA as a completely separate team that tests
everything once the development team has &ldquo;finished&rdquo; the features and
bug fixes for the next release is very much out of line with every
agile methodology. Agile processes are (to me at least) about faster
feedback and the possibility to change direction quickly. So for
example, if you were doing SCRUM with one week sprints, do a feature
freeze every month (you know, management won&rsquo;t let you release each
week), and only <em>then</em> start testing all the features and bug fixes
there&rsquo;s quite a lot of overhead. The QA process may take a while as
everything produced in a month needs to be tested, the developers have
already moved on to new features and now have to switch <em>back</em> to
fixing their old code (which is quite a mental overhead) and once
everything has been tested, fixed, and tested again it&rsquo;s already 2-3
weeks later.</p>

<!-- more -->


<p>A better approach I found is to have the testing being done right
after the feature or bug fix is finished. Assuming you have automated
tests and an automated deployment process (I&rsquo;m assuming that you&rsquo;re
developing a web app) you can just have your continuous integration
server run the tests and once they pass deploy the latest version of
the code to your staging server and notify the tester. That way the
tester can do the checking right away and send feedback within hours
or even minutes. After such a short amount of time the developer in
charge probably still knows enough about the code so that he can
quickly fix the issues the tester found.</p>

<p>Obviously a final round of QA before getting a release out the door is
still necessary, but as it can be assumed that all features and bug
fixes are correctly implemented this can now be much shorter and needs
to be less thorough. That way the release can be shipping much faster,
any you know maybe you can even ship more often than once a month.</p>
]]></content>
  </entry>
  
</feed>
