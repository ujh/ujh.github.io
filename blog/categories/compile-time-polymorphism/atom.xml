<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: compile time polymorphism | Urban Hafner]]></title>
  <link href="http://bettong.net/blog/categories/compile-time-polymorphism/atom.xml" rel="self"/>
  <link href="http://bettong.net/"/>
  <updated>2015-12-07T18:00:44+01:00</updated>
  <id>http://bettong.net/</id>
  <author>
    <name><![CDATA[Urban Hafner]]></name>
    <email><![CDATA[contact@urbanhafner.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning Rust: Compile time polymorphism]]></title>
    <link href="http://bettong.net/2014/07/24/learning-rust-compile-time-polymorphism/"/>
    <updated>2014-07-24T08:13:51+02:00</updated>
    <id>http://bettong.net/2014/07/24/learning-rust-compile-time-polymorphism</id>
    <content type="html"><![CDATA[<p>Coming from Ruby, polymorphism is a big part of the language. After
all Ruby is a (mostly) object oriented language. Going to a language
like Rust which is compiled and has an emphasis on being fast, run time
polymorphism isn&rsquo;t that nice as it slows down the code.  This is
because there&rsquo;s the overhead of selecting the right implementation of
a method at runtime and also because there&rsquo;s no way these calls can be
inlined.</p>

<p>This is where compile time polymorphism comes in. Many times it is
clear at compile time which concrete type we&rsquo;re going to use in the
program. We could write it down explicitly, but it is nicer (and more
flexible) if the compiler can figure it out for us.</p>

<!-- more -->


<p>Below is a small example of how this works. <code>Implementer1</code> and
<code>Implementer2</code> are two structs that both implement the trait
<code>TheTrait</code>. The third struct, <code>Container</code>, should be setup in such a
way that it can store any struct that implements <code>TheTrait</code>.</p>

<p>Setting this up correctly in Rust is a tiny bit complicated. First,
you need to let Rust know that you want to use a type variable when
defining <code>Container</code>. To do this you write <code>Container&lt;T&gt;</code> and then use
<code>T</code> wherever you want to refer to this type in the struct definition.
You will notice that this never mentions the trait <code>TheTrait</code>. The
place where you actually restrict this variable to the trait is in the
concrete implementation of the <code>Container</code> struct. Note that the
variable I&rsquo;ve used in the definition of <code>Container</code> (called <code>T</code>) is
different from the one I&rsquo;ve used in the implementation (called <code>X</code>).
Normally you wouldn&rsquo;t do this as this makes the code much harder to
understand, but I wanted to show that this is &ldquo;just&rdquo; a variable.</p>

<pre><code class="rust compile-time-polymorphic-structs.rs">#[deriving(Show)]
struct Implementer1;
#[deriving(Show)]
struct Implementer2;
#[deriving(Show)]
struct Container&lt;T&gt; { s: T }

trait TheTrait {}

impl TheTrait for Implementer1 {}
impl TheTrait for Implementer2 {}
impl&lt;X: TheTrait&gt; Container&lt;X&gt; {}

fn main() {
    let c1 = Container { s: Implementer1 };
    let c2 = Container { s: Implementer2 };
    println!("c1 = {}", c1);
    println!("c2 = {}", c2);
}
</code></pre>

<p>To prove that I haven&rsquo;t told you any lies, let&rsquo;s compile the program
and run it. You&rsquo;ll clearly see that <code>c1</code> contains <code>Implementer1</code> and
<code>c2</code> contains <code>Implementer2</code>.</p>

<pre><code class="plain">$ rustc compile-time-polymorphic-struct.rs
$ ./compile-time-polymorphic-struct
c1 = Container { s: Implementer1 }
c2 = Container { s: Implementer2 }
</code></pre>

<p>Next time we&rsquo;ll talk about how to do actual runtime polymorphism in
Rust. After all it&rsquo;s not always possible to know the type at compile time!</p>
]]></content>
  </entry>
  
</feed>
