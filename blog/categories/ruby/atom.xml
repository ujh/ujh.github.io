<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Urban Hafner]]></title>
  <link href="http://bettong.net/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://bettong.net/"/>
  <updated>2016-05-20T11:42:05+02:00</updated>
  <id>http://bettong.net/</id>
  <author>
    <name><![CDATA[Urban Hafner]]></name>
    <email><![CDATA[contact@urbanhafner.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Two talks on isolating your domain logic from Rails]]></title>
    <link href="http://bettong.net/2014/08/08/two-talks-on-isolating-your-domain-logic-from-rails/"/>
    <updated>2014-08-08T09:29:49+02:00</updated>
    <id>http://bettong.net/2014/08/08/two-talks-on-isolating-your-domain-logic-from-rails</id>
    <content type="html"><![CDATA[<p>Recently one of my co-workers pointed me to this great talk by the
late Jim Weirich about separating the domain logic of your Ruby on
Rails app from &ldquo;the plumbing&rdquo;:</p>

<!-- more -->




<iframe width="640" height="360"
src="//www.youtube-nocookie.com/embed/tg5RFeSfBM4?rel=0"
frameborder="0" allowfullscreen></iframe>


<p>This the led me to the Hexagonal Rails talk by Matt Wynne:</p>

<iframe width="640" height="360"
src="//www.youtube-nocookie.com/embed/CGN4RFkhH2M?rel=0"
frameborder="0" allowfullscreen></iframe>


<p>Now, I&rsquo;m off to finally read
<a href="http://www.growing-object-oriented-software.com/">Growing Object-Oriented Software Guided by Tests</a>
and try to give decoupling my logic from the Ruby on Rails guts a real try!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using sass-rails 3.1.5 without the asset pipeline on Rails 3.1.4]]></title>
    <link href="http://bettong.net/2012/03/07/using-sass-rails-3-dot-1-5-without-the-asset-pipeline-on-rails-3-dot-1-4/"/>
    <updated>2012-03-07T17:29:00+01:00</updated>
    <id>http://bettong.net/2012/03/07/using-sass-rails-3-dot-1-5-without-the-asset-pipeline-on-rails-3-dot-1-4</id>
    <content type="html"><![CDATA[<p>I&rsquo;m currently upgrading one of the Ruby on Rails apps from Rails 3.0 to Rails 3.1. As it so happens we&rsquo;re using <a href="http://activeadmin.info/">ActiveAdmin</a> with it which requires <a href="https://github.com/rails/sass-rails">sass-rails</a> on Rails 3.1. At the time of writing the latest version of <a href="https://github.com/rails/sass-rails">sass-rails</a> is 3.1.5 and it requires the asset pipeline to be enabled. But I don&rsquo;t want to upgrade from <a href="http://documentcloud.github.com/jammit/">jammit</a> at this time so I have to disable the asset pipeline. But with the asset pipeline disabled the app can&rsquo;t start due to <a href="https://github.com/rails/sass-rails">sass-rails</a>. So here&rsquo;s what I needed to do to make it work.</p>

<h3>config/environment.rb</h3>

<p>I had to change it so that it looks like the code snippet below. Basically this fakes the asset pipeline for the benefit of <a href="https://github.com/rails/sass-rails">sass-rails</a>.</p>

<pre><code class="ruby"># Load the rails application
require File.expand_path('../application', __FILE__)

Webanalyzer::Application.assets = Struct.new(:context_class) do
  def append_path(*args); end
end.new(Class.new)

# Initialize the rails application
Webanalyzer::Application.initialize!
</code></pre>

<h3>config/application.rb</h3>

<p>Disable compilation of the assets alongside disabling the asset pipeline as a whole.</p>

<pre><code class="ruby">config.assets.enabled = false
config.assets.compile = false
</code></pre>

<h3>Done!</h3>

<p>The two small changes fixed <a href="https://github.com/rails/sass-rails">sass-rails</a> without the asset pipeline for now. Hopefully <a href="https://github.com/rails/sass-rails/pull/84">pull request #84</a> will be merged into sass-rails soon and a new version will be released so that this hack won&rsquo;t be necessary. Until then this is the most basic fix I could come up with.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eloquent Ruby -- The final verdict]]></title>
    <link href="http://bettong.net/2012/03/02/eloquent-ruby-the-final-verdict/"/>
    <updated>2012-03-02T21:25:00+01:00</updated>
    <id>http://bettong.net/2012/03/02/eloquent-ruby-the-final-verdict</id>
    <content type="html"><![CDATA[<p>This will be my final post on Eloquent Ruby by Russ Olsen. All in all I really liked the book and I think that if you&rsquo;re serious about being a Ruby developer this book should be in your library.</p>

<p>It is a valuable book for several reasons. First of all it is as close as humanly possible to a definite style guide for programming in Ruby. This doesn&rsquo;t just cover formatting your code and if or when to use camel case but more importantly when and how to use certain parts of the language. Secondly, it contains a lot of best practices, especially on the use of modules, classes and meta-programming. And thirdly it explains some of the more advances parts of Ruby extremely well. For example I never knew the difference between <code>lambda</code> and <code>Proc.new</code> and what hooks Ruby provides to help you with meta-programming.</p>

<p>So please do yourself a favor and read the book. More than once!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Eloquent Ruby #3]]></title>
    <link href="http://bettong.net/2011/11/07/notes-on-eloquent-ruby-number-3/"/>
    <updated>2011-11-07T15:11:00+01:00</updated>
    <id>http://bettong.net/2011/11/07/notes-on-eloquent-ruby-number-3</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;m focusing on chapter 13: <em>Get the Behavior You Need with Singleton and Class Methods</em>. This chapter was a nice wow moment for me, but also a bit embarrassing as this isn&rsquo;t really advanced Ruby knowledge but I&rsquo;ve managed to never really learn it. So what does the chapter talk about? It talks about Ruby singleton and class methods and that they&rsquo;re basically the same thing under the hood!</p>

<h3>What?</h3>

<p>So we all know that we can define class methods like this:</p>

<pre><code class="ruby">class DennisMoore
  def self.riding_through_the_night
    # ...
  end
end
</code></pre>

<p>And we also know that this is equivalent to the following:</p>

<pre><code class="ruby">class DennisMoore
end

def DennisMoore.riding_through_the_night
  # ...
end
</code></pre>

<p>Now let&rsquo;s compare this to defining a method on an object instead of a class (aka defining a singleton method):</p>

<pre><code class="ruby">obj = Object.new
def obj.bla
  # ...
end
</code></pre>

<p>Quite similar that code, isn&rsquo;t it? This could just be a coincidence, but of course being a nicely designed language it isn&rsquo;t.</p>

<h3>So how does it work?</h3>

<p>Quite easily actually. As you know Ruby is an object oriented language down to it&rsquo;s core. So it comes naturally that classes are just objects, too. So when you are defining class methods you are actually defining singleton methods on the instance of <tt>Class</tt> that defines your class (<tt>DennisMoore</tt> in this case) which is no different from defining singleton methods on &ldquo;normal&rdquo; objects!</p>

<h3>And where are those methods stored?</h3>

<p>Now that we know that we are just defining singleton methods the only question remaining is where these methods are stored? Remember, when we are calling a method on an object, Ruby searches for the method in the class of the object, then the super class and so on until it finds it. But of course we can&rsquo;t put our singleton methods into the class as we only want these methods to be defined for that single object. So we could come up with some hack that stores the methods somehow in the instance. Or, we could do the elegant thing and add a special class to each object that sits between it and the &ldquo;real&rdquo; class of that object. This way we can use the normal rules of inheritance for singleton methods. This is of course what Ruby does. It calls it the <em>singleton class</em> even.</p>

<h3>Wrapping up</h3>

<p>So to summarize: Each Ruby object has a <em>singleton class</em> in the method lookup path between itself and its class. That&rsquo;s where singleton methods are defined. And class methods are just a special case of this as classes themselves are just objects (and instances of class <tt>Class</tt>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Eloquent Ruby #2]]></title>
    <link href="http://bettong.net/2011/11/03/notes-on-eloquent-ruby-number-2/"/>
    <updated>2011-11-03T16:31:00+01:00</updated>
    <id>http://bettong.net/2011/11/03/notes-on-eloquent-ruby-number-2</id>
    <content type="html"><![CDATA[<p>In this second post we look at chapter 10: <em>Construct Your Classes from Short, Focused Methods</em>. The first thing that comes to mind is of course that methods should be short. Some years ago my rule of thumb was that a method should fit on the screen. But now that I&rsquo;m using a 27&#8217;&lsquo; screen that doesn&rsquo;t hold true anymore, of course. Also this misses the important point of the chapter and that is: use the <em>composed method</em> technique for your methods. Paraphrasing the book the method written using the composed method technique should have three characteristics:</p>

<ol>
<li>They should do a single thing only</li>
<li>They should operate on a single conceptual level, i.e. they shouldn&rsquo;t mix high-level and low-level things</li>
<li>They need to have a descriptive names, i.e. names that describe the purpose of the method</li>
</ol>


<p>Adhering to these rules gives you nicely structured methods that should be easily understandable and as a side benefit they are also easily testable as each method only does one small thing and therefore there&rsquo;s no need for extensive mocking and setting up context.</p>
]]></content>
  </entry>
  
</feed>
